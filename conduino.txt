-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lightweight composable continuation-based stream processors
--   
--   A lightweight continuation-based stream processing library.
--   
--   It is similar in nature to pipes and conduit, but useful if you just
--   want something quick to manage composable stream processing without
--   focus on IO.
--   
--   See README for more information.
@package conduino
@version 0.2.0.0


-- | Internal module exposing the internals of <a>Pipe</a>, including its
--   underlying representation and base functor.
module Data.Conduino.Internal

-- | Similar to a conduit from the <i>conduit</i> package.
--   
--   For a <tt><a>Pipe</a> i o u m a</tt>, you have:
--   
--   <ul>
--   <li><tt>i</tt>: Type of input stream (the things you can
--   <a>await</a>)</li>
--   <li><tt>o</tt>: Type of output stream (the things you
--   <a>yield</a>)</li>
--   <li><tt>u</tt>: Type of the <i>result</i> of the upstream pipe
--   (Outputted when upstream pipe terminates)</li>
--   <li><tt>m</tt>: Underlying monad (the things you can <a>lift</a>)</li>
--   <li><tt>a</tt>: Result type when pipe terminates (outputted when
--   finished, with <a>pure</a> or <a>return</a>)</li>
--   </ul>
--   
--   Some specializations:
--   
--   <ul>
--   <li>If <tt>i</tt> is <tt>()</tt>, the pipe is a <i>source</i> --- it
--   doesn't need anything to produce items. It will pump out items on its
--   own, for pipes downstream to receive and process.</li>
--   <li>If <tt>o</tt> is <tt>Void</tt>, the pipe is a <i>sink</i> --- it
--   will never <a>yield</a> anything downstream. It will consume items
--   from things upstream, and produce a result (<tt>a</tt>) if and when it
--   terminates.</li>
--   <li>If <tt>u</tt> is <tt>Void</tt>, then the pipe's upstream is
--   limitless, and never terminates. This means that you can use
--   <a>awaitSurely</a> instead of <a>await</a>, to get await a value that
--   is guaranteed to come. You'll get an <tt>i</tt> instead of a
--   <tt><a>Maybe</a> i</tt>.</li>
--   <li>If <tt>a</tt> is <tt>Void</tt>, then the pipe never terminates ---
--   it will keep on consuming and/or producing values forever. If this is
--   a sink, it means that the sink will never terminate, and so
--   <a>runPipe</a> will also never terminate. If it is a source, it means
--   that if you chain something downstream with <a>.|</a>, that downstream
--   pipe can use <tt>awaitSurely</tt> to guarantee something being passed
--   down.</li>
--   </ul>
--   
--   Applicative and Monadic sequencing of pipes chains by exhaustion.
--   
--   <pre>
--   do pipeX
--      pipeY
--      pipeZ
--   </pre>
--   
--   is a pipe itself, that behaves like <tt>pipeX</tt> until it
--   terminates, then <tt>pipeY</tt> until it terminates, then
--   <tt>pipeZ</tt> until it terminates. The <a>Monad</a> instance allows
--   you to choose "which pipe to behave like next" based on the
--   terminating result of a previous pipe.
--   
--   <pre>
--   do x &lt;- pipeX
--      pipeBasedOn x
--   </pre>
--   
--   Usually you would use it by chaining together pipes with <a>.|</a> and
--   then running the result with <a>runPipe</a>.
--   
--   <pre>
--   <a>runPipe</a> $ someSource
--          <a>.|</a> somePipe
--          .| someOtherPipe
--          .| someSink
--   </pre>
--   
--   See <a>.|</a> and <a>runPipe</a> for more information on usage.
--   
--   For a "prelude" of commonly used <a>Pipe</a>s, see
--   <a>Data.Condunio.Combinators</a>.
newtype Pipe i o u m a
Pipe :: FT (PipeF i o u) m a -> Pipe i o u m a
[pipeFree] :: Pipe i o u m a -> FT (PipeF i o u) m a

-- | Base functor of <a>Pipe</a>.
--   
--   A pipe fundamentally has the ability to await and the ability to
--   yield. The other functionality are implemented.
--   
--   <ul>
--   <li>Lifting effects is implemented by the <a>MonadTrans</a> and
--   <a>MonadIO</a> instances that <a>FT</a> gives.</li>
--   <li><i>Ending</i> with a result is implemented by the
--   <a>Applicative</a> instance's <a>pure</a> that <a>FT</a> gives.</li>
--   <li>Applicative and monadic sequenceing "after a pipe is done" is
--   implemented by the <a>Applicative</a> and <a>Monad</a> instances that
--   <a>FT</a> gives.</li>
--   </ul>
--   
--   On top of these we implement <a>.|</a> and other combinators based on
--   the structure that <a>FT</a> gives. For some functions, it can be
--   easier to use an alternative encoding, <a>RecPipe</a>, which is the
--   same thing but explicitly recursive.
data PipeF i o u a
PAwaitF :: (u -> a) -> (i -> a) -> PipeF i o u a
PYieldF :: o -> a -> PipeF i o u a

-- | Await on upstream output. Will block until it receives an <tt>i</tt>
--   (expected input type) or a <tt>u</tt> if the upstream pipe terminates.
awaitEither :: Pipe i o u m (Either u i)

-- | Send output downstream.
yield :: o -> Pipe i o u m ()

-- | Map over the input type, output type, and upstream result type.
--   
--   If you want to map over the result type, use <a>fmap</a>.
trimapPipe :: (i -> j) -> (p -> o) -> (u -> v) -> Pipe j p v m a -> Pipe i o u m a

-- | (Contravariantly) map over the expected input type.
mapInput :: (i -> j) -> Pipe j o u m a -> Pipe i o u m a

-- | Map over the downstream output type.
--   
--   If you want to map over the result type, use <a>fmap</a>.
mapOutput :: (p -> o) -> Pipe i p u m a -> Pipe i o u m a

-- | (Contravariantly) map over the upstream result type.
mapUpRes :: (u -> v) -> Pipe i o v m a -> Pipe i o u m a

-- | Transform the underlying monad of a pipe.
hoistPipe :: (Monad m, Monad n) => (forall x. m x -> n x) -> Pipe i o u m a -> Pipe i o u n a

-- | A version of <a>Pipe</a> that uses explicit, concrete recursion
--   instead of church-encoding like <a>Pipe</a>. Some functions ---
--   especially ones that combine multiple pipes into one --- are easier to
--   implement in this form.
type RecPipe i o u = FreeT (PipeF i o u)

-- | Convert from a <a>Pipe</a> to a <a>RecPipe</a>. While most of this
--   library is defined in terms of <a>Pipe</a>, it can be easier to write
--   certain low-level pipe combining functions in terms of <a>RecPipe</a>
--   than <a>Pipe</a>.
toRecPipe :: Monad m => Pipe i o u m a -> RecPipe i o u m a

-- | Convert a <a>RecPipe</a> back into a <a>Pipe</a>.
fromRecPipe :: Monad m => RecPipe i o u m a -> Pipe i o u m a

-- | Convenint wrapper over <a>toRecPipe</a> and <tt>fromRecType</tt>.
withRecPipe :: (Monad m, Monad n) => (RecPipe i o u m a -> RecPipe j p v n b) -> Pipe i o u m a -> Pipe j p v n b
pAwaitF :: forall m_a872 i_a4LE o_a4LF u_a4LG. MonadFree (PipeF i_a4LE o_a4LF u_a4LG) m_a872 => m_a872 (Either u_a4LG i_a4LE)
pYieldF :: forall m_a89p i_a4LE o_a4LF u_a4LG. MonadFree (PipeF i_a4LE o_a4LF u_a4LG) m_a89p => o_a4LF -> m_a89p ()
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Data.Conduino.Internal.Pipe i o u m)
instance GHC.Base.Alternative m => GHC.Base.Alternative (Data.Conduino.Internal.Pipe i o u m)
instance (Control.Monad.Reader.Class.MonadReader r m, Control.Monad.Writer.Class.MonadWriter w m, Control.Monad.State.Class.MonadState s m) => Control.Monad.RWS.Class.MonadRWS r w s (Data.Conduino.Internal.Pipe i o u m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Data.Conduino.Internal.Pipe i o u m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Data.Conduino.Internal.Pipe i o u m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Data.Conduino.Internal.Pipe i o u m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Data.Conduino.Internal.Pipe i o u m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Data.Conduino.Internal.Pipe i o u m)
instance Control.Monad.Free.Class.MonadFree (Data.Conduino.Internal.PipeF i o u) (Data.Conduino.Internal.Pipe i o u m)
instance Control.Monad.Trans.Class.MonadTrans (Data.Conduino.Internal.Pipe i o u)
instance GHC.Base.Monad (Data.Conduino.Internal.Pipe i o u m)
instance GHC.Base.Applicative (Data.Conduino.Internal.Pipe i o u m)
instance GHC.Base.Functor (Data.Conduino.Internal.Pipe i o u m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Data.Conduino.Internal.Pipe i o u m)
instance GHC.Base.Functor (Data.Conduino.Internal.PipeF i o u)


-- | Base API for <a>Pipe</a>. See documentation for <a>Pipe</a>,
--   <a>.|</a>, and <a>runPipe</a> for information on usage.
--   
--   A "prelude" of useful pipes can be found in
--   <a>Data.Conduino.Combinators</a>.
--   
--   <h2>Why a stream processing library?</h2>
--   
--   A stream processing library is a way to stream processors in a
--   <i>composable</i> way: instead of defining your entire stream
--   processing function as a single recursive loop with some global state,
--   instead think about each "stage" of the process, and isolate each
--   state to its own segment. Each component can contain its own isolated
--   state:
--   
--   <pre>
--   &gt;&gt;&gt; runPipePure $ sourceList [1..10]
--         .| scan (+) 0
--         .| sinkList
--   [1,3,6,10,15,21,28,36,45,55]
--   </pre>
--   
--   All of these components have internal "state":
--   
--   <ul>
--   <li><tt>sourceList</tt> keeps track of "which" item in the list to
--   yield next</li>
--   <li><tt>scan</tt> keeps track of the current running sum</li>
--   <li><tt>sinkList</tt> keeps track of all items that have been seen so
--   far, as a list</li>
--   </ul>
--   
--   They all work together without knowing any other component's internal
--   state, so you can write your total streaming function without
--   concerning yourself, at each stage, with the entire part.
--   
--   In addition, there are useful functions to "combine" stream
--   processors:
--   
--   <ul>
--   <li><a>zipSink</a> combines sinks in an "and" sort of way: combine two
--   sinks in parallel and finish when all finish.</li>
--   <li><a>altSink</a> combines sinks in an "or" sort of way: combine two
--   sinks in parallel and finish when any of them finish</li>
--   <li><tt>zipSource</tt> combines sources in parallel and collate their
--   outputs.</li>
--   </ul>
--   
--   Stream processing libraries are also useful for streaming composition
--   of monadic effects (like IO or State), as well.
module Data.Conduino

-- | Similar to a conduit from the <i>conduit</i> package.
--   
--   For a <tt><a>Pipe</a> i o u m a</tt>, you have:
--   
--   <ul>
--   <li><tt>i</tt>: Type of input stream (the things you can
--   <a>await</a>)</li>
--   <li><tt>o</tt>: Type of output stream (the things you
--   <a>yield</a>)</li>
--   <li><tt>u</tt>: Type of the <i>result</i> of the upstream pipe
--   (Outputted when upstream pipe terminates)</li>
--   <li><tt>m</tt>: Underlying monad (the things you can <a>lift</a>)</li>
--   <li><tt>a</tt>: Result type when pipe terminates (outputted when
--   finished, with <a>pure</a> or <a>return</a>)</li>
--   </ul>
--   
--   Some specializations:
--   
--   <ul>
--   <li>If <tt>i</tt> is <tt>()</tt>, the pipe is a <i>source</i> --- it
--   doesn't need anything to produce items. It will pump out items on its
--   own, for pipes downstream to receive and process.</li>
--   <li>If <tt>o</tt> is <tt>Void</tt>, the pipe is a <i>sink</i> --- it
--   will never <a>yield</a> anything downstream. It will consume items
--   from things upstream, and produce a result (<tt>a</tt>) if and when it
--   terminates.</li>
--   <li>If <tt>u</tt> is <tt>Void</tt>, then the pipe's upstream is
--   limitless, and never terminates. This means that you can use
--   <a>awaitSurely</a> instead of <a>await</a>, to get await a value that
--   is guaranteed to come. You'll get an <tt>i</tt> instead of a
--   <tt><a>Maybe</a> i</tt>.</li>
--   <li>If <tt>a</tt> is <tt>Void</tt>, then the pipe never terminates ---
--   it will keep on consuming and/or producing values forever. If this is
--   a sink, it means that the sink will never terminate, and so
--   <a>runPipe</a> will also never terminate. If it is a source, it means
--   that if you chain something downstream with <a>.|</a>, that downstream
--   pipe can use <tt>awaitSurely</tt> to guarantee something being passed
--   down.</li>
--   </ul>
--   
--   Applicative and Monadic sequencing of pipes chains by exhaustion.
--   
--   <pre>
--   do pipeX
--      pipeY
--      pipeZ
--   </pre>
--   
--   is a pipe itself, that behaves like <tt>pipeX</tt> until it
--   terminates, then <tt>pipeY</tt> until it terminates, then
--   <tt>pipeZ</tt> until it terminates. The <a>Monad</a> instance allows
--   you to choose "which pipe to behave like next" based on the
--   terminating result of a previous pipe.
--   
--   <pre>
--   do x &lt;- pipeX
--      pipeBasedOn x
--   </pre>
--   
--   Usually you would use it by chaining together pipes with <a>.|</a> and
--   then running the result with <a>runPipe</a>.
--   
--   <pre>
--   <a>runPipe</a> $ someSource
--          <a>.|</a> somePipe
--          .| someOtherPipe
--          .| someSink
--   </pre>
--   
--   See <a>.|</a> and <a>runPipe</a> for more information on usage.
--   
--   For a "prelude" of commonly used <a>Pipe</a>s, see
--   <a>Data.Condunio.Combinators</a>.
data Pipe i o u m a

-- | The main operator for chaining pipes together. <tt>pipe1 .| pipe2</tt>
--   will connect the output of <tt>pipe1</tt> to the input of
--   <tt>pipe2</tt>.
--   
--   <a>Running</a> a pipe will draw from <tt>pipe2</tt>, and if
--   <tt>pipe2</tt> ever asks for input (with <a>await</a> or something
--   similar), it will block until <tt>pipe1</tt> outputs something (or
--   signals termination).
--   
--   The structure of a full pipeline usually looks like:
--   
--   <pre>
--   <a>runPipe</a> $ someSource
--          <a>.|</a> somePipe
--          .| someOtherPipe
--          .| someSink
--   </pre>
--   
--   Where you route a source into a series of pipes, which eventually ends
--   up at a sink. <a>runPipe</a> will then produce the result of that
--   sink.
(.|) :: Monad m => Pipe a b u m v -> Pipe b c v m r -> Pipe a c u m r
infixr 2 .|

-- | Run a pipe that is both a source and a sink (an "effect") into the
--   effect that it represents.
--   
--   Usually you wouild construct this using something like:
--   
--   <pre>
--   <a>runPipe</a> $ someSource
--          <a>.|</a> somePipe
--          .| someOtherPipe
--          .| someSink
--   </pre>
--   
--   <a>runPipe</a> will produce the result of that final sink.
--   
--   Some common errors you might receive:
--   
--   <ul>
--   <li><tt>i</tt> is not <tt>()</tt>: If you give a pipe where the first
--   parameter ("input") is not <tt>()</tt>, it means that your pipe is not
--   a producer. Pre-compose it (using <a>.|</a>) with a producer of the
--   type you need.</li>
--   </ul>
--   
--   For example, if you have a <tt>myPipe :: <a>Pipe</a> <a>Int</a> o u m
--   a</tt>, this is a pipe that is awaiting <a>Int</a>s from upstream.
--   Pre-compose with a producer of <a>Int</a>s, like <tt><a>sourceList</a>
--   [1,2,3] <a>.|</a> myPipe</tt>, in order to be able to run it.
--   
--   <ul>
--   <li><tt>o</tt> is not <a>Void</a>: If you give a pipe where the second
--   parameter ("output") is not <a>Void</a>, it means that your pipe is
--   not a consumer. Post-compose it (using <a>.|</a>) with a consumer of
--   the type you need.</li>
--   </ul>
--   
--   For example, if you have <tt>myPipe :: <a>Pipe</a> i <a>Int</a> u m
--   a</tt>, this is a pipe that is yielding <a>Int</a>s downstream that
--   are going unhandled. Post-compose it a consumer of <a>Int</a>s, like
--   <tt>myPipe <a>.|</a> <a>foldl</a> (+) 0</tt>, in order to be able to
--   run it.
--   
--   If you just want to ignore all downstream yields, post-compose with
--   <a>sinkNull</a>.
runPipe :: Monad m => Pipe () Void u m a -> m a

-- | <a>runPipe</a> when the underlying monad is <a>Identity</a>, and so
--   has no effects.
runPipePure :: Pipe () Void Void Identity a -> a

-- | Await on upstream output. Will block until it receives an <tt>i</tt>
--   (expected input type) or a <tt>u</tt> if the upstream pipe terminates.
awaitEither :: Pipe i o u m (Either u i)

-- | Await input from upstream. Will block until upstream <a>yield</a>s.
--   
--   Will return <a>Nothing</a> if the upstream pipe finishes and
--   terminates.
--   
--   If the upstream pipe never terminates, then you can use
--   <a>awaitSurely</a> to guarantee a result.
--   
--   Will always return <a>Just</a> if <tt>u</tt> is <a>Void</a>.
await :: Pipe i o u m (Maybe i)

-- | <a>await</a>, but directly chaining a continuation if the <a>await</a>
--   was succesful.
--   
--   The await will always be succesful if <tt>u</tt> is <a>Void</a>.
--   
--   This is a way of writing code in a way that is agnostic to how the
--   upstream pipe terminates.
awaitWith :: (i -> Pipe i o u m u) -> Pipe i o u m u

-- | Await input from upstream where the upstream pipe is guaranteed to
--   never terminate.
--   
--   A common type error will occur if <tt>u</tt> (upstream pipe result
--   type) is not <a>Void</a> -- it might be <tt>()</tt> or some
--   non-<a>Void</a> type. This means that the upstream pipe terminates, so
--   awaiting cannot be assured.
--   
--   In that case, either change your upstream pipe to be one that never
--   terminates (which is most likely not possible), or use <a>await</a>
--   instead of <a>awaitSurely</a>.
awaitSurely :: Pipe i o Void m i

-- | A useful utility function over repeated <a>await</a>s. Will repeatedly
--   <a>await</a> and then continue with the given pipe whenever the
--   upstream pipe yields.
--   
--   Can be used to implement many pipe combinators:
--   
--   <pre>
--   <a>map</a> f = <a>awaitForever</a> $ x -&gt; <a>yield</a> (f x)
--   </pre>
awaitForever :: (i -> Pipe i o u m a) -> Pipe i o u m u

-- | Send output downstream.
yield :: o -> Pipe i o u m ()

-- | (Contravariantly) map over the expected input type.
mapInput :: (i -> j) -> Pipe j o u m a -> Pipe i o u m a

-- | Map over the downstream output type.
--   
--   If you want to map over the result type, use <a>fmap</a>.
mapOutput :: (p -> o) -> Pipe i p u m a -> Pipe i o u m a

-- | (Contravariantly) map over the upstream result type.
mapUpRes :: (u -> v) -> Pipe i o v m a -> Pipe i o u m a

-- | Map over the input type, output type, and upstream result type.
--   
--   If you want to map over the result type, use <a>fmap</a>.
trimapPipe :: (i -> j) -> (p -> o) -> (u -> v) -> Pipe j p v m a -> Pipe i o u m a

-- | Transform the underlying monad of a pipe.
hoistPipe :: (Monad m, Monad n) => (forall x. m x -> n x) -> Pipe i o u m a -> Pipe i o u n a

-- | <a>Squeeze</a> a pipe by extracting all output that can be extracted
--   before any input is requested. Returns a <a>Left</a> if the pipe
--   eventually does request input (as a continuation on the new input), or
--   a <a>Right</a> if the pipe terminates with a value before ever asking
--   for input.
squeezePipe :: Monad m => Pipe i o u m a -> m ([o], Either (i -> Pipe i o u m a) a)

-- | <a>Squeeze</a> a pipe by extracting all output that can be extracted
--   before any input is requested. Returns a <a>Left</a> if the pipe
--   eventually does request input (as a continuation on the new input, or
--   a terminating <tt>u</tt> value), or a <a>Right</a> if the pipe
--   terminates with a value before ever asking for input.
squeezePipeEither :: Monad m => Pipe i o u m a -> m ([o], Either (Either u i -> Pipe i o u m a) a)

-- | Repeatedly run <a>squeezePipe</a> by giving it items from an input
--   list. Returns the outputs observed, and <a>Left</a> if the input list
--   was exhausted with more input expected, or <a>Right</a> if the pipe
--   terminated, with the leftover inputs and output result.
feedPipe :: Monad m => [i] -> Pipe i o u m a -> m ([o], Either (i -> Pipe i o u m a) ([i], a))

-- | Repeatedly run <a>squeezePipeEither</a> by giving it items from an
--   input list. Returns the outputs observed, and <a>Left</a> if the input
--   list was exhausted with more input expected (or a <tt>u</tt>
--   terminating upstream value), or <a>Right</a> if the pipe terminated,
--   with the leftover inputs and output result.
feedPipeEither :: Monad m => [i] -> Pipe i o u m a -> m ([o], Either (Either u i -> Pipe i o u m a) ([i], a))

-- | A newtype wrapper over a source (<tt><a>Pipe</a> () o
--   <a>Void</a></tt>) that gives it an alternative <a>Applicative</a> and
--   <a>Alternative</a> instance, matching "ListT done right".
--   
--   <a>&lt;*&gt;</a> will pair up each output that the sources produce: if
--   you <a>await</a> a value from downstream, it will wait until both
--   paired sources yield before passing them on together.
--   
--   <a>&lt;|&gt;</a> will completely exhaust the first source before
--   moving on to the next source.
--   
--   <a>ZipSource</a> is effectively equivalent to "ListT done right", the
--   true List Monad transformer. <a>&lt;|&gt;</a> is concatentation. You
--   can use this type with <a>lift</a> to lift a yielding action and
--   <a>&lt;|&gt;</a> to sequence yields to implement the pattern described
--   in
--   <a>http://www.haskellforall.com/2014/11/how-to-build-library-agnostic-streaming.html</a>,
--   where you can write streaming producers in a polymorphic way, and have
--   it run with pipes, conduit, etc.
--   
--   The main difference is that its <a>Applicative</a> instance
--   ("zipping") is different from the traditional <a>Applicative</a>
--   instance for <a>ListT</a> ("all combinations"). Effectively this
--   becomes like a "zipping" <a>Applicative</a> instance for <a>ListT</a>.
--   
--   If you want a <a>Monad</a> (or <a>MonadIO</a>) instance, use
--   <a>ListT</a> instead, and convert using
--   <a>toListT</a>/<a>fromListT</a> or the <a>PipeList</a>
--   pattern/constructor.
newtype ZipSource m a
ZipSource :: Pipe () a Void m () -> ZipSource m a
[getZipSource] :: ZipSource m a -> Pipe () a Void m ()

-- | <a>ZipSource</a> is effectively <a>ListT</a> returning a <a>Maybe</a>.
--   As such, you can use <a>unconsZipSource</a> to "peel off" the first
--   yielded item, if it exists, and return the "rest of the list".
unconsZipSource :: Monad m => ZipSource m a -> m (Maybe (Maybe a, ZipSource m a))

-- | A newtype wrapper over a sink (<tt><a>Pipe</a> i <a>Void</a></tt>)
--   that gives it an alternative <a>Applicative</a> and <a>Alternative</a>
--   instance.
--   
--   <a>&lt;*&gt;</a> will distribute input over both sinks, and output a
--   final result once both sinks finish.
--   
--   <a>&lt;|&gt;</a> will distribute input over both sinks, and output a
--   final result as soon as one or the other finishes.
newtype ZipSink i u m a
ZipSink :: Pipe i Void u m a -> ZipSink i u m a
[getZipSink] :: ZipSink i u m a -> Pipe i Void u m a

-- | Distribute input to both sinks, and finishes with the final result
--   once both finish.
--   
--   Forms an identity with <a>pure</a>.
zipSink :: Monad m => Pipe i Void u m (a -> b) -> Pipe i Void u m a -> Pipe i Void u m b

-- | Distribute input to both sinks, and finishes with the result of the
--   one that finishes first.
altSink :: Monad m => Pipe i Void u m a -> Pipe i Void u m a -> Pipe i Void u m a

-- | A source is essentially equivalent to <a>ListT</a> producing a
--   <a>Maybe</a> result. This converts it to the <a>ListT</a> it encodes.
--   
--   See <a>ZipSource</a> for a wrapper over <a>Pipe</a> that gives the
--   right <a>Functor</a> and <a>Alternative</a> instances.
toListT :: Applicative m => Pipe () o u m () -> ListT m (Maybe o)

-- | A source is essentially <a>ListT</a> producing a <a>Maybe</a> result.
--   This converts a <a>ListT</a> to the source it encodes.
--   
--   See <a>ZipSource</a> for a wrapper over <a>Pipe</a> that gives the
--   right <a>Functor</a> and <a>Alternative</a> instances.
fromListT :: Monad m => ListT m (Maybe o) -> Pipe i o u m ()

-- | A source is equivalent to a <a>ListT</a> producing a <a>Maybe</a>;
--   this pattern synonym lets you treat it as such. It essentialyl wraps
--   over <a>toListT</a> and <a>fromListT</a>.
pattern PipeList :: Monad m => ListT m (Maybe a) -> Pipe () a u m ()

-- | A source can be "run" by providing a continuation to handle and
--   sequence each of its outputs. Is ths inverse of <a>genSource</a>.
--   
--   This essentially turns a pipe into a church-encoded <a>ListT</a>.
withSource :: Pipe () o u m () -> (Maybe (o, m r) -> m r) -> m r

-- | Given a "generator" of <tt>o</tt> in <tt>m</tt>, return a
--   <i>source</i> that that generator encodes. Is the inverse of
--   <a>withSource</a>.
--   
--   The generator is essentially a church-encoded <a>ListT</a>.
genSource :: (forall r. (Maybe (o, m r) -> m r) -> m r) -> Pipe i o u m ()
instance GHC.Base.Functor (Data.Conduino.ZipSink i u m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Data.Conduino.ZipSink i u m)
instance GHC.Base.Monad m => GHC.Base.Alternative (Data.Conduino.ZipSink i u m)
instance Control.Monad.Trans.Class.MonadTrans (Data.Conduino.ZipSink i u)
instance GHC.Base.Functor (Data.Conduino.ZipSource m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Data.Conduino.ZipSource m)
instance GHC.Base.Monad m => GHC.Base.Alternative (Data.Conduino.ZipSource m)
instance Control.Monad.Trans.Class.MonadTrans Data.Conduino.ZipSource


-- | A basic collection of base <a>Pipe</a>s that serve as a "prelude" for
--   the package. This module is meant to be imported qualified.
--   
--   <pre>
--   import qualified Data.Conduino.Combinators as C
--   </pre>
module Data.Conduino.Combinators

-- | Repeatedly apply an "unfolding" function to a given initial state,
--   yielding the first item in the tuple as output and updating the state
--   as the second item in the tuple. Goes on forever. See
--   <a>unfoldMaybe</a> for a version that stops.
unfold :: (s -> (o, s)) -> s -> Pipe i o u m a

-- | Repeatedly apply a function to a given starting value and yield each
--   result forever.
--   
--   <pre>
--   &gt;&gt;&gt; runPipePure $ iterate succ 0
--         .| take 5
--         .| sinkList
--   </pre>
--   
--   <ul>
--   <li><i>1,2,3,4,5</i></li>
--   </ul>
--   
--   This doesn't yield the original starting value. However, you can yield
--   it iterate after:
--   
--   <pre>
--   &gt;&gt;&gt; runPipePure $ (yield 0 &gt;&gt; iterate succ 0)
--         .| take 5
--         .| sinkList
--   </pre>
--   
--   <ul>
--   <li><i>0,1,2,3,4,5</i></li>
--   </ul>
iterate :: (o -> o) -> o -> Pipe i o u m a

-- | Repeatedly yield a given item forever.
repeat :: o -> Pipe i o u m a

-- | A version of <a>unfold</a> that can terminate and end by returning
--   <a>Nothing</a>.
unfoldMaybe :: (s -> Maybe (o, s)) -> s -> Pipe i o u m ()

-- | A version of <a>unfoldMaybe</a> that can choose the "result" value by
--   passing it in as <a>Left</a>.
unfoldEither :: (s -> Either a (o, s)) -> s -> Pipe i o u m a

-- | A version of <a>iterate</a> that can choose to terminate and stop by
--   returning <a>Nothing</a>.
iterateMaybe :: (o -> Maybe o) -> o -> Pipe i o u m ()

-- | A version of <a>iterateMaybe</a> that can specify a result value by
--   providing it in the <a>Left</a>.
iterateEither :: (o -> Either a o) -> o -> Pipe i o u m a

-- | Yield every item in a foldable container.
sourceList :: Foldable t => t a -> Pipe i a u m ()

-- | Yield a given item a certain number of times.
replicate :: Int -> o -> Pipe i o u m ()

-- | Repeat a monadic action forever, yielding each output.
--   
--   Remember that each item will only be "executed" when something
--   downstream requests output.
repeatM :: Monad m => m o -> Pipe i o u m a

-- | Repeat a monadic action, yielding the item in the <a>Just</a> every
--   time. As soon as it sees <a>Nothing</a>, stop producing forever.
--   
--   Remember that each item will only be "executed" when something
--   downstream requests output.
repeatMaybeM :: Monad m => m (Maybe o) -> Pipe i o u m ()

-- | Like <a>repeatMaybeM</a>, but allow specification of a final result
--   type.
repeatEitherM :: Monad m => m (Either a o) -> Pipe i o u m a

-- | Repeat a monadic action a given number of times, yielding each result,
--   and then stop producing forever.
--   
--   Remember that each item will only be "executed" when something
--   downstream requests output.
replicateM :: Monad m => Int -> m o -> Pipe i o u m ()

-- | Source from a given I/O handle, yielding each line drawn as a string.
--   To draw raw bytes, use <a>sourceHandle</a>.
--   
--   This stop as soon as end-of-file is reached, or an empty line is seen.
sourceHandleLines :: MonadIO m => Handle -> Pipe i String u m ()

-- | Source from each line received from <a>stdin</a>. This stops as soon
--   as end-of-file is reached, or an empty line is seen.
stdinLines :: MonadIO m => Pipe i String u m ()

-- | Source from a given I/O handle, yielding bytestrings as they are
--   pulled. If you want to retrieve each line as a string, see
--   <a>sourceHandleLines</a>.
sourceHandle :: MonadIO m => Handle -> Pipe i ByteString u m ()

-- | Source from stdin, yielding bytestrings as they are drawn. If you want
--   to retrieve each line as a string, see <a>stdinLines</a>.
stdin :: MonadIO m => Pipe i ByteString u m ()

-- | Process every incoming item with a pure function, and yield its
--   output.
map :: (i -> o) -> Pipe i o u m u

-- | Map a monadic function to process every input, and yield its output.
mapM :: Monad m => (i -> m o) -> Pipe i o u m u

-- | Like <a>foldl</a>, but yields every accumulator value downstream.
--   
--   <pre>
--   &gt;&gt;&gt; runPipePure $ sourceList [1..10]
--         .| scan (+) 0
--         .| sinkList
--   [1,3,6,10,15,21,28,36,45,55]
--   @
--   </pre>
scan :: (o -> i -> o) -> o -> Pipe i o u m u

-- | Map a pure "stateful" function over each incoming item. Give a
--   function to update the state and return an output and an initial
--   state.
mapAccum :: (i -> s -> (s, o)) -> s -> Pipe i o u m u

-- | Let a given number of items pass through the stream uninhibited, and
--   then stop producing forever.
--   
--   This is most useful if you sequence a second conduit after it.
--   
--   <pre>
--   &gt;&gt;&gt; runPipePure $ sourceList [1..8]
--         .| (do take 3 .| map (*2)         -- double the first 3 items
--                map negate                 -- negate the rest
--            )
--         .| sinkList
--   [2,4,6,-4,-5,-6,-7,-8]
--   </pre>
take :: Int -> Pipe i i u m ()

-- | Let elements pass until an element is received that does not satisfy
--   the predicate, then stop producing forever.
--   
--   Like <a>take</a>, is most useful if you sequence a second conduit
--   after it.
takeWhile :: (i -> Bool) -> Pipe i i u m ()

-- | Only allow values satisfying a predicate to pass.
filter :: (i -> Bool) -> Pipe i i u m u

-- | Map a function returning a container onto every incoming item, and
--   yield all of the outputs from that function.
concatMap :: Foldable t => (i -> t o) -> Pipe i o u m u

-- | Take an input of containers and output each of their elements
--   successively.
concat :: Foldable t => Pipe (t i) i u m u

-- | Yield consecutive pairs of values.
--   
--   <pre>
--   &gt;&gt;&gt; runPipePure $ sourceList [1..5]
--         .| pairs
--         .| sinkList
--   [(1,2),(2,3),(3,4),(4,5)]
--   </pre>
pairs :: Pipe i (i, i) u m u

-- | Yield consecutive runs of at most <tt>n</tt> of values, starting with
--   an empty sequence.
--   
--   To get only "full" sequences, pipe with <a>filter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; runPipePure $ sourceList [1..6]
--         .| consecutive 3
--         .| map toList
--         .| sinkList
--   [[],[1],[1,2],[1,2,3],[2,3,4],[3,4,5],[4,5,6]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runPipePure $ sourceList [1..6]
--         .| consecutive 3
--         .| filter ((== 3) . Seq.length)
--         .| map toList
--         .| sinkList
--   [[1,2,3],[2,3,4],[3,4,5],[4,5,6]]
--   </pre>
consecutive :: Int -> Pipe i (Seq i) u m u

-- | Ignore a certain amount of items from the input stream, and then stop
--   producing forever.
--   
--   This is most useful if you sequence a second consumer after it:
--   
--   <pre>
--   &gt;&gt;&gt; runPipePure $ sourceList [1..8]
--         .| (drop 3 &gt;&gt; 'sinkList')
--   [4,5,6,7,8]
--   </pre>
drop :: Int -> Pipe i o u m ()

-- | Ignore items from an input stream as long as they match a predicate.
--   Afterwards, stop producing forever.
--   
--   Like for <a>drop</a>, is most useful of you sequence a second consumer
--   after it.
dropWhile :: (i -> Bool) -> Pipe i o u m ()

-- | Right-fold every input into an accumulated value.
--   
--   Essentially this builds up a giant continuation that will be run all
--   at once on the final result.
foldr :: (a -> b -> b) -> b -> Pipe a o u m b

-- | Left-fold every input into an accumulated value.
--   
--   Essentially this maintains a state and modifies that state with every
--   input, using the given accumulating function.
foldl :: (b -> a -> b) -> b -> Pipe a o u m b

-- | Fold every incoming item according to a monoidal projection, and
--   return the result once finished.
--   
--   This can be used to implement many useful consumers, like ones that
--   find the sum or the maximum item:
--   
--   <pre>
--   sum :: Num i =&gt; Pipe i o u m i
--   sum = getSum <a>$</a> foldMap Sum
--   
--   maximum :: Ord i =&gt; Pipe i o u m (Maybe i)
--   maximum = fmap getMax <a>$</a> foldMap (Just . Max)
--   </pre>
foldMap :: Monoid a => (i -> a) -> Pipe i o u m a

-- | Fold every incoming item monoidally, and return the result once
--   finished.
fold :: Monoid a => Pipe a o u m a

-- | Consume an entire input stream and ignore all of its outputs.
sinkNull :: Pipe i o u m ()

-- | Sink every incoming item into a list.
--   
--   Note that this keeps the entire list in memory until it is all
--   eventually read.
sinkList :: Pipe i o u m [i]

-- | Get the last item emitted by a stream.
--   
--   To get the first item ("head"), use <a>await</a> or
--   <a>awaitSurely</a>.
last :: Pipe i o u m (Maybe i)

-- | Sink into a given I/O handle, writing each input to the handle.
sinkHandle :: MonadIO m => Handle -> Pipe ByteString o u m ()

-- | A sink into stdout.
stdout :: MonadIO m => Pipe ByteString o u m ()

-- | A sink into stderr.
stderr :: MonadIO m => Pipe ByteString o u m ()

module Data.Conduino.Lift
