-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lightweight composable continuation-based stream processors
--   
--   A lightweight continuation-based stream processing library.
--   
--   It is similar in nature to pipes and conduit, but useful if you just
--   want something quick to manage composable stream processing without
--   focus on IO.
--   
--   See README for more information.
@package conduino
@version 0.2.1.0


-- | Internal module exposing the internals of <a>Pipe</a>, including its
--   underlying representation and base functor.
module Data.Conduino.Internal

-- | Similar to a conduit from the <i>conduit</i> package.
--   
--   For a <tt><a>Pipe</a> i o u m a</tt>, you have:
--   
--   <ul>
--   <li><tt>i</tt>: Type of input stream (the things you can
--   <a>await</a>)</li>
--   <li><tt>o</tt>: Type of output stream (the things you
--   <a>yield</a>)</li>
--   <li><tt>u</tt>: Type of the <i>result</i> of the upstream pipe
--   (Outputted when upstream pipe terminates)</li>
--   <li><tt>m</tt>: Underlying monad (the things you can <a>lift</a>)</li>
--   <li><tt>a</tt>: Result type when pipe terminates (outputted when
--   finished, with <a>pure</a> or <a>return</a>)</li>
--   </ul>
--   
--   Some specializations:
--   
--   <ul>
--   <li>If <tt>i</tt> is <tt>()</tt>, the pipe is a <i>source</i> --- it
--   doesn't need anything to produce items. It will pump out items on its
--   own, for pipes downstream to receive and process.</li>
--   <li>If <tt>o</tt> is <a>Void</a>, the pipe is a <i>sink</i> --- it
--   will never <a>yield</a> anything downstream. It will consume items
--   from things upstream, and produce a result (<tt>a</tt>) if and when it
--   terminates.</li>
--   <li>If <tt>u</tt> is <a>Void</a>, then the pipe's upstream is
--   limitless, and never terminates. This means that you can use
--   <a>awaitSurely</a> instead of <a>await</a>, to get await a value that
--   is guaranteed to come. You'll get an <tt>i</tt> instead of a
--   <tt><a>Maybe</a> i</tt>.</li>
--   <li>If <tt>a</tt> is <a>Void</a>, then the pipe never terminates ---
--   it will keep on consuming and/or producing values forever. If this is
--   a sink, it means that the sink will never terminate, and so
--   <a>runPipe</a> will also never terminate. If it is a source, it means
--   that if you chain something downstream with <a>.|</a>, that downstream
--   pipe can use <a>awaitSurely</a> to guarantee something being passed
--   down.</li>
--   </ul>
--   
--   Applicative and Monadic sequencing of pipes chains by exhaustion.
--   
--   <pre>
--   do pipeX
--      pipeY
--      pipeZ
--   </pre>
--   
--   is a pipe itself, that behaves like <tt>pipeX</tt> until it
--   terminates, then <tt>pipeY</tt> until it terminates, then
--   <tt>pipeZ</tt> until it terminates. The <a>Monad</a> instance allows
--   you to choose "which pipe to behave like next" based on the
--   terminating result of a previous pipe.
--   
--   <pre>
--   do x &lt;- pipeX
--      pipeBasedOn x
--   </pre>
--   
--   Usually you would use it by chaining together pipes with <a>.|</a> and
--   then running the result with <a>runPipe</a>.
--   
--   <pre>
--   <a>runPipe</a> $ someSource
--          <a>.|</a> somePipe
--          .| someOtherPipe
--          .| someSink
--   </pre>
--   
--   See <a>.|</a> and <a>runPipe</a> for more information on usage.
--   
--   For a "prelude" of commonly used <a>Pipe</a>s, see
--   <a>Data.Conduino.Combinators</a>.
newtype Pipe i o u m a
Pipe :: FT (PipeF i o u) m a -> Pipe i o u m a
[pipeFree] :: Pipe i o u m a -> FT (PipeF i o u) m a

-- | Base functor of <a>Pipe</a>.
--   
--   A pipe fundamentally has the ability to await and the ability to
--   yield. The other functionality are implemented.
--   
--   <ul>
--   <li>Lifting effects is implemented by the <a>MonadTrans</a> and
--   <a>MonadIO</a> instances that <a>FT</a> gives.</li>
--   <li><i>Ending</i> with a result is implemented by the
--   <a>Applicative</a> instance's <a>pure</a> that <a>FT</a> gives.</li>
--   <li>Applicative and monadic sequenceing "after a pipe is done" is
--   implemented by the <a>Applicative</a> and <a>Monad</a> instances that
--   <a>FT</a> gives.</li>
--   </ul>
--   
--   On top of these we implement <a>.|</a> and other combinators based on
--   the structure that <a>FT</a> gives. For some functions, it can be
--   easier to use an alternative encoding, <a>RecPipe</a>, which is the
--   same thing but explicitly recursive.
data PipeF i o u a
PAwaitF :: (u -> a) -> (i -> a) -> PipeF i o u a
PYieldF :: o -> a -> PipeF i o u a

-- | Await on upstream output. Will block until it receives an <tt>i</tt>
--   (expected input type) or a <tt>u</tt> if the upstream pipe terminates.
awaitEither :: Pipe i o u m (Either u i)

-- | Send output downstream.
yield :: o -> Pipe i o u m ()

-- | Map over the input type, output type, and upstream result type.
--   
--   If you want to map over the result type, use <a>fmap</a>.
trimapPipe :: (i -> j) -> (p -> o) -> (u -> v) -> Pipe j p v m a -> Pipe i o u m a

-- | (Contravariantly) map over the expected input type.
mapInput :: (i -> j) -> Pipe j o u m a -> Pipe i o u m a

-- | Map over the downstream output type.
--   
--   If you want to map over the result type, use <a>fmap</a>.
mapOutput :: (p -> o) -> Pipe i p u m a -> Pipe i o u m a

-- | (Contravariantly) map over the upstream result type.
mapUpRes :: (u -> v) -> Pipe i o v m a -> Pipe i o u m a

-- | Transform the underlying monad of a pipe.
--   
--   Note that if you are trying to work with monad transformers, this is
--   probably not what you want. See <a>Data.Conduino.Lift</a> for tools
--   for working with underlying monad transformers.
hoistPipe :: (Monad m, Monad n) => (forall x. m x -> n x) -> Pipe i o u m a -> Pipe i o u n a

-- | A version of <a>Pipe</a> that uses explicit, concrete recursion
--   instead of church-encoding like <a>Pipe</a>. Some functions ---
--   especially ones that combine multiple pipes into one --- are easier to
--   implement in this form.
type RecPipe i o u = FreeT (PipeF i o u)

-- | Convert from a <a>Pipe</a> to a <a>RecPipe</a>. While most of this
--   library is defined in terms of <a>Pipe</a>, it can be easier to write
--   certain low-level pipe combining functions in terms of <a>RecPipe</a>
--   than <a>Pipe</a>.
toRecPipe :: Monad m => Pipe i o u m a -> RecPipe i o u m a

-- | Convert a <a>RecPipe</a> back into a <a>Pipe</a>.
fromRecPipe :: Monad m => RecPipe i o u m a -> Pipe i o u m a

-- | Convenint wrapper over <a>toRecPipe</a> and <a>fromRecPipe</a>.
withRecPipe :: (Monad m, Monad n) => (RecPipe i o u m a -> RecPipe j p v n b) -> Pipe i o u m a -> Pipe j p v n b

-- | Turn a <a>Pipe</a> that runs over <a>StateT</a> into a
--   "state-modifying <a>Pipe</a>", that returns the final state when it
--   terminates.
--   
--   The main usage of this is to "isolate" the state from other pipes in
--   the same chain. For example, of <tt>p</tt>, <tt>q</tt>, and <tt>r</tt>
--   are all pipes under <a>StateT</a>, then:
--   
--   <pre>
--      p
--   .| q
--   .| r
--   </pre>
--   
--   will all share underlying state, and each can modify the state that
--   they all three share. We essentially have global state.
--   
--   However, if you use <a>runStateP</a>, you can all have them use
--   different encapsulated states.
--   
--   <pre>
--      void (runStateP s0 p)
--   .| void (runStateP s1 q)
--   .| runStateP s2 r
--   </pre>
--   
--   In this case, each of those three chained pipes will use their own
--   internal states, without sharing.
--   
--   This is also useful if you want to chain a pipe over <a>StateT</a>
--   with pipes that don't use state at all: for example if <tt>a</tt> and
--   <tt>b</tt> are "non-stateful" pipes (<i>not</i> over <a>StateT</a>),
--   you can do:
--   
--   <pre>
--      a
--   .| void (runStateP s1 q)
--   .| b
--   </pre>
--   
--   And <tt>a</tt> and <tt>b</tt> will be none the wiser to the fact that
--   <tt>q</tt> uses <a>StateT</a> internally.
--   
--   Note to avoid the usage of <a>void</a>, <a>evalStateP</a> might be
--   more useful.
runStateP :: Monad m => s -> Pipe i o u (StateT s m) a -> Pipe i o u m (a, s)
pAwaitF :: forall m_a9x3 i_a6Gp o_a6Gq u_a6Gr. MonadFree (PipeF i_a6Gp o_a6Gq u_a6Gr) m_a9x3 => m_a9x3 (Either u_a6Gr i_a6Gp)
pYieldF :: forall m_a9zq i_a6Gp o_a6Gq u_a6Gr. MonadFree (PipeF i_a6Gp o_a6Gq u_a6Gr) m_a9zq => o_a6Gq -> m_a9zq ()
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Data.Conduino.Internal.Pipe i o u m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Data.Conduino.Internal.Pipe i o u m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Data.Conduino.Internal.Pipe i o u m)
instance GHC.Base.Alternative m => GHC.Base.Alternative (Data.Conduino.Internal.Pipe i o u m)
instance (Control.Monad.Reader.Class.MonadReader r m, Control.Monad.Writer.Class.MonadWriter w m, Control.Monad.State.Class.MonadState s m) => Control.Monad.RWS.Class.MonadRWS r w s (Data.Conduino.Internal.Pipe i o u m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Data.Conduino.Internal.Pipe i o u m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Data.Conduino.Internal.Pipe i o u m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Data.Conduino.Internal.Pipe i o u m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Data.Conduino.Internal.Pipe i o u m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Data.Conduino.Internal.Pipe i o u m)
instance Control.Monad.Free.Class.MonadFree (Data.Conduino.Internal.PipeF i o u) (Data.Conduino.Internal.Pipe i o u m)
instance Control.Monad.Trans.Class.MonadTrans (Data.Conduino.Internal.Pipe i o u)
instance GHC.Base.Monad (Data.Conduino.Internal.Pipe i o u m)
instance GHC.Base.Applicative (Data.Conduino.Internal.Pipe i o u m)
instance GHC.Base.Functor (Data.Conduino.Internal.Pipe i o u m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Data.Conduino.Internal.Pipe i o u m)
instance GHC.Base.Functor (Data.Conduino.Internal.PipeF i o u)


-- | Base API for <a>Pipe</a>. See documentation for <a>Pipe</a>,
--   <a>.|</a>, and <a>runPipe</a> for information on usage.
--   
--   A "prelude" of useful pipes can be found in
--   <a>Data.Conduino.Combinators</a>.
--   
--   <h2>Why a stream processing library?</h2>
--   
--   A stream processing library is a way to stream processors in a
--   <i>composable</i> way: instead of defining your entire stream
--   processing function as a single recursive loop with some global state,
--   instead think about each "stage" of the process, and isolate each
--   state to its own segment. Each component can contain its own isolated
--   state:
--   
--   <pre>
--   &gt;&gt;&gt; runPipePure $ sourceList [1..10]
--         .| scan (+) 0
--         .| sinkList
--   [1,3,6,10,15,21,28,36,45,55]
--   </pre>
--   
--   All of these components have internal "state":
--   
--   <ul>
--   <li><tt>sourceList</tt> keeps track of "which" item in the list to
--   yield next</li>
--   <li><tt>scan</tt> keeps track of the current running sum</li>
--   <li><tt>sinkList</tt> keeps track of all items that have been seen so
--   far, as a list</li>
--   </ul>
--   
--   They all work together without knowing any other component's internal
--   state, so you can write your total streaming function without
--   concerning yourself, at each stage, with the entire part.
--   
--   In addition, there are useful functions to "combine" stream
--   processors:
--   
--   <ul>
--   <li><a>zipSink</a> combines sinks in an "and" sort of way: combine two
--   sinks in parallel and finish when all finish.</li>
--   <li><a>altSink</a> combines sinks in an "or" sort of way: combine two
--   sinks in parallel and finish when any of them finish</li>
--   <li><a>zipSource</a> combines sources in parallel and collate their
--   outputs.</li>
--   </ul>
--   
--   Stream processing libraries are also useful for streaming composition
--   of monadic effects (like IO or State), as well.
module Data.Conduino

-- | Similar to a conduit from the <i>conduit</i> package.
--   
--   For a <tt><a>Pipe</a> i o u m a</tt>, you have:
--   
--   <ul>
--   <li><tt>i</tt>: Type of input stream (the things you can
--   <a>await</a>)</li>
--   <li><tt>o</tt>: Type of output stream (the things you
--   <a>yield</a>)</li>
--   <li><tt>u</tt>: Type of the <i>result</i> of the upstream pipe
--   (Outputted when upstream pipe terminates)</li>
--   <li><tt>m</tt>: Underlying monad (the things you can <a>lift</a>)</li>
--   <li><tt>a</tt>: Result type when pipe terminates (outputted when
--   finished, with <a>pure</a> or <a>return</a>)</li>
--   </ul>
--   
--   Some specializations:
--   
--   <ul>
--   <li>If <tt>i</tt> is <tt>()</tt>, the pipe is a <i>source</i> --- it
--   doesn't need anything to produce items. It will pump out items on its
--   own, for pipes downstream to receive and process.</li>
--   <li>If <tt>o</tt> is <a>Void</a>, the pipe is a <i>sink</i> --- it
--   will never <a>yield</a> anything downstream. It will consume items
--   from things upstream, and produce a result (<tt>a</tt>) if and when it
--   terminates.</li>
--   <li>If <tt>u</tt> is <a>Void</a>, then the pipe's upstream is
--   limitless, and never terminates. This means that you can use
--   <a>awaitSurely</a> instead of <a>await</a>, to get await a value that
--   is guaranteed to come. You'll get an <tt>i</tt> instead of a
--   <tt><a>Maybe</a> i</tt>.</li>
--   <li>If <tt>a</tt> is <a>Void</a>, then the pipe never terminates ---
--   it will keep on consuming and/or producing values forever. If this is
--   a sink, it means that the sink will never terminate, and so
--   <a>runPipe</a> will also never terminate. If it is a source, it means
--   that if you chain something downstream with <a>.|</a>, that downstream
--   pipe can use <a>awaitSurely</a> to guarantee something being passed
--   down.</li>
--   </ul>
--   
--   Applicative and Monadic sequencing of pipes chains by exhaustion.
--   
--   <pre>
--   do pipeX
--      pipeY
--      pipeZ
--   </pre>
--   
--   is a pipe itself, that behaves like <tt>pipeX</tt> until it
--   terminates, then <tt>pipeY</tt> until it terminates, then
--   <tt>pipeZ</tt> until it terminates. The <a>Monad</a> instance allows
--   you to choose "which pipe to behave like next" based on the
--   terminating result of a previous pipe.
--   
--   <pre>
--   do x &lt;- pipeX
--      pipeBasedOn x
--   </pre>
--   
--   Usually you would use it by chaining together pipes with <a>.|</a> and
--   then running the result with <a>runPipe</a>.
--   
--   <pre>
--   <a>runPipe</a> $ someSource
--          <a>.|</a> somePipe
--          .| someOtherPipe
--          .| someSink
--   </pre>
--   
--   See <a>.|</a> and <a>runPipe</a> for more information on usage.
--   
--   For a "prelude" of commonly used <a>Pipe</a>s, see
--   <a>Data.Conduino.Combinators</a>.
data Pipe i o u m a

-- | The main operator for chaining pipes together. <tt>pipe1 .| pipe2</tt>
--   will connect the output of <tt>pipe1</tt> to the input of
--   <tt>pipe2</tt>.
--   
--   <a>Running</a> a pipe will draw from <tt>pipe2</tt>, and if
--   <tt>pipe2</tt> ever asks for input (with <a>await</a> or something
--   similar), it will block until <tt>pipe1</tt> outputs something (or
--   signals termination).
--   
--   The structure of a full pipeline usually looks like:
--   
--   <pre>
--   <a>runPipe</a> $ someSource
--          <a>.|</a> somePipe
--          .| someOtherPipe
--          .| someSink
--   </pre>
--   
--   Where you route a source into a series of pipes, which eventually ends
--   up at a sink. <a>runPipe</a> will then produce the result of that
--   sink.
(.|) :: Monad m => Pipe a b u m v -> Pipe b c v m r -> Pipe a c u m r
infixr 2 .|

-- | Run a pipe that is both a source and a sink (an "effect") into the
--   effect that it represents.
--   
--   Usually you wouild construct this using something like:
--   
--   <pre>
--   <a>runPipe</a> $ someSource
--          <a>.|</a> somePipe
--          .| someOtherPipe
--          .| someSink
--   </pre>
--   
--   <a>runPipe</a> will produce the result of that final sink.
--   
--   Some common errors you might receive:
--   
--   <ul>
--   <li><tt>i</tt> is not <tt>()</tt>: If you give a pipe where the first
--   parameter ("input") is not <tt>()</tt>, it means that your pipe is not
--   a producer. Pre-compose it (using <a>.|</a>) with a producer of the
--   type you need.</li>
--   </ul>
--   
--   For example, if you have a <tt>myPipe :: <a>Pipe</a> <a>Int</a> o u m
--   a</tt>, this is a pipe that is awaiting <a>Int</a>s from upstream.
--   Pre-compose with a producer of <a>Int</a>s, like <tt><a>sourceList</a>
--   [1,2,3] <a>.|</a> myPipe</tt>, in order to be able to run it.
--   
--   <ul>
--   <li><tt>o</tt> is not <a>Void</a>: If you give a pipe where the second
--   parameter ("output") is not <a>Void</a>, it means that your pipe is
--   not a consumer. Post-compose it (using <a>.|</a>) with a consumer of
--   the type you need.</li>
--   </ul>
--   
--   For example, if you have <tt>myPipe :: <a>Pipe</a> i <a>Int</a> u m
--   a</tt>, this is a pipe that is yielding <a>Int</a>s downstream that
--   are going unhandled. Post-compose it a consumer of <a>Int</a>s, like
--   <tt>myPipe <a>.|</a> <a>foldl</a> (+) 0</tt>, in order to be able to
--   run it.
--   
--   If you just want to ignore all downstream yields, post-compose with
--   <a>sinkNull</a>.
runPipe :: Monad m => Pipe () Void u m a -> m a

-- | <a>runPipe</a> when the underlying monad is <a>Identity</a>, and so
--   has no effects.
runPipePure :: Pipe () Void Void Identity a -> a

-- | Await on upstream output. Will block until it receives an <tt>i</tt>
--   (expected input type) or a <tt>u</tt> if the upstream pipe terminates.
awaitEither :: Pipe i o u m (Either u i)

-- | Await input from upstream. Will block until upstream <a>yield</a>s.
--   
--   Will return <a>Nothing</a> if the upstream pipe finishes and
--   terminates.
--   
--   If the upstream pipe never terminates, then you can use
--   <a>awaitSurely</a> to guarantee a result.
--   
--   Will always return <a>Just</a> if <tt>u</tt> is <a>Void</a>.
await :: Pipe i o u m (Maybe i)

-- | <a>await</a>, but directly chaining a continuation if the <a>await</a>
--   was succesful.
--   
--   The await will always be succesful if <tt>u</tt> is <a>Void</a>.
--   
--   This is a way of writing code in a way that is agnostic to how the
--   upstream pipe terminates.
awaitWith :: (i -> Pipe i o u m u) -> Pipe i o u m u

-- | Await input from upstream where the upstream pipe is guaranteed to
--   never terminate.
--   
--   A common type error will occur if <tt>u</tt> (upstream pipe result
--   type) is not <a>Void</a> -- it might be <tt>()</tt> or some
--   non-<a>Void</a> type. This means that the upstream pipe terminates, so
--   awaiting cannot be assured.
--   
--   In that case, either change your upstream pipe to be one that never
--   terminates (which is most likely not possible), or use <a>await</a>
--   instead of <a>awaitSurely</a>.
awaitSurely :: Pipe i o Void m i

-- | A useful utility function over repeated <a>await</a>s. Will repeatedly
--   <a>await</a> and then continue with the given pipe whenever the
--   upstream pipe yields.
--   
--   Can be used to implement many pipe combinators:
--   
--   <pre>
--   <a>map</a> f = <a>awaitForever</a> $ x -&gt; <a>yield</a> (f x)
--   </pre>
awaitForever :: (i -> Pipe i o u m a) -> Pipe i o u m u

-- | Send output downstream.
yield :: o -> Pipe i o u m ()

-- | Like <tt>.|</tt>, but get the result of <i>both</i> pipes on
--   termination, instead of just the second. This means that <tt>p &amp;|
--   q</tt> will only terminate with a result when <i>both</i> <tt>p</tt>
--   and <tt>q</tt> terminate. (Typically, <tt>p .| q</tt> would terminate
--   as soon as <tt>q</tt> terminates.)
(&|) :: Monad m => Pipe a b u m v -> Pipe b c v m r -> Pipe a c u m (v, r)
infixr 2 &|

-- | Like <tt>.|</tt>, but keep the result of the <i>first</i> pipe,
--   instead of the second. This means that <tt>p |. q</tt> will only
--   terminate with a result when <i>both</i> <tt>p</tt> and <tt>q</tt>
--   terminate. (Typically, <tt>p .| q</tt> would terminate as soon as
--   <tt>q</tt> terminates.)
(|.) :: Monad m => Pipe a b u m v -> Pipe b c v m r -> Pipe a c u m v
infixr 2 |.

-- | Useful prefix version of <a>&amp;|</a>.
fuseBoth :: Monad m => Pipe a b u m v -> Pipe b c v m r -> Pipe a c u m (v, r)

-- | Useful prefix version of <a>|.</a>.
fuseUpstream :: Monad m => Pipe a b u m v -> Pipe b c v m r -> Pipe a c u m v

-- | Like <a>fuseBoth</a> and <a>&amp;|</a>, except does not wait for the
--   upstream pipe to terminate. Return <a>Nothing</a> in the first field
--   if the upstream pipe hasn't terminated, and <a>Just</a> if it has,
--   with the terminating value.
fuseBothMaybe :: Monad m => Pipe a b u m v -> Pipe b c v m r -> Pipe a c u m (Maybe v, r)

-- | <a>Squeeze</a> a pipe by extracting all output that can be extracted
--   before any input is requested. Returns a <a>Left</a> if the pipe
--   eventually does request input (as a continuation on the new input), or
--   a <a>Right</a> if the pipe terminates with a value before ever asking
--   for input.
squeezePipe :: Monad m => Pipe i o u m a -> m ([o], Either (i -> Pipe i o u m a) a)

-- | <a>Squeeze</a> a pipe by extracting all output that can be extracted
--   before any input is requested. Returns a <a>Left</a> if the pipe
--   eventually does request input (as a continuation on the new input, or
--   a terminating <tt>u</tt> value), or a <a>Right</a> if the pipe
--   terminates with a value before ever asking for input.
squeezePipeEither :: Monad m => Pipe i o u m a -> m ([o], Either (Either u i -> Pipe i o u m a) a)

-- | Repeatedly run <a>squeezePipe</a> by giving it items from an input
--   list. Returns the outputs observed, and <a>Left</a> if the input list
--   was exhausted with more input expected, or <a>Right</a> if the pipe
--   terminated, with the leftover inputs and output result.
feedPipe :: Monad m => [i] -> Pipe i o u m a -> m ([o], Either (i -> Pipe i o u m a) ([i], a))

-- | Repeatedly run <a>squeezePipeEither</a> by giving it items from an
--   input list. Returns the outputs observed, and <a>Left</a> if the input
--   list was exhausted with more input expected (or a <tt>u</tt>
--   terminating upstream value), or <a>Right</a> if the pipe terminated,
--   with the leftover inputs and output result.
feedPipeEither :: Monad m => [i] -> Pipe i o u m a -> m ([o], Either (Either u i -> Pipe i o u m a) ([i], a))

-- | (Contravariantly) map over the expected input type.
mapInput :: (i -> j) -> Pipe j o u m a -> Pipe i o u m a

-- | Map over the downstream output type.
--   
--   If you want to map over the result type, use <a>fmap</a>.
mapOutput :: (p -> o) -> Pipe i p u m a -> Pipe i o u m a

-- | (Contravariantly) map over the upstream result type.
mapUpRes :: (u -> v) -> Pipe i o v m a -> Pipe i o u m a

-- | Map over the input type, output type, and upstream result type.
--   
--   If you want to map over the result type, use <a>fmap</a>.
trimapPipe :: (i -> j) -> (p -> o) -> (u -> v) -> Pipe j p v m a -> Pipe i o u m a

-- | Transform the underlying monad of a pipe.
--   
--   Note that if you are trying to work with monad transformers, this is
--   probably not what you want. See <a>Data.Conduino.Lift</a> for tools
--   for working with underlying monad transformers.
hoistPipe :: (Monad m, Monad n) => (forall x. m x -> n x) -> Pipe i o u m a -> Pipe i o u n a

-- | Loop a pipe into itself.
--   
--   <ul>
--   <li>Will feed all output back to the input</li>
--   <li>Will only ask for input upstream if output is stalled.</li>
--   <li>Yields all outputted values downstream, effectively duplicating
--   them.</li>
--   </ul>
feedbackPipe :: Monad m => Pipe x x u m a -> Pipe x x u m a

-- | A newtype wrapper over a source (<tt><a>Pipe</a> () o
--   <a>Void</a></tt>) that gives it an alternative <a>Applicative</a> and
--   <a>Alternative</a> instance, matching "ListT done right".
--   
--   <a>&lt;*&gt;</a> will pair up each output that the sources produce: if
--   you <a>await</a> a value from downstream, it will wait until both
--   paired sources yield before passing them on together.
--   
--   <a>&lt;|&gt;</a> will completely exhaust the first source before
--   moving on to the next source.
--   
--   <a>ZipSource</a> is effectively equivalent to "ListT done right", the
--   true List Monad transformer. <a>&lt;|&gt;</a> is concatentation. You
--   can use this type with <a>lift</a> to lift a yielding action and
--   <a>&lt;|&gt;</a> to sequence yields to implement the pattern described
--   in
--   <a>http://www.haskellforall.com/2014/11/how-to-build-library-agnostic-streaming.html</a>,
--   where you can write streaming producers in a polymorphic way, and have
--   it run with pipes, conduit, etc.
--   
--   The main difference is that its <a>Applicative</a> instance
--   ("zipping") is different from the traditional <a>Applicative</a>
--   instance for <a>ListT</a> ("all combinations"). Effectively this
--   becomes like a "zipping" <a>Applicative</a> instance for <a>ListT</a>.
--   
--   If you want a <a>Monad</a> (or <a>MonadIO</a>) instance, use
--   <a>ListT</a> instead, and convert using
--   <a>toListT</a>/<a>fromListT</a> or the <a>PipeList</a>
--   pattern/constructor.
newtype ZipSource m a
ZipSource :: Pipe () a Void m () -> ZipSource m a
[getZipSource] :: ZipSource m a -> Pipe () a Void m ()

-- | <a>ZipSource</a> is effectively <a>ListT</a> returning a <a>Maybe</a>.
--   As such, you can use <a>unconsZipSource</a> to "peel off" the first
--   yielded item, if it exists, and return the "rest of the list".
unconsZipSource :: Monad m => ZipSource m a -> m (Maybe (Maybe a, ZipSource m a))

-- | Takes two sources and runs them in parallel, collating their outputs.
zipSource :: Monad m => Pipe () (a -> b) u m () -> Pipe () a v m () -> Pipe () b w m ()

-- | A newtype wrapper over a sink (<tt><a>Pipe</a> i <a>Void</a></tt>)
--   that gives it an alternative <a>Applicative</a> and <a>Alternative</a>
--   instance.
--   
--   <a>&lt;*&gt;</a> will distribute input over both sinks, and output a
--   final result once both sinks finish.
--   
--   <a>&lt;|&gt;</a> will distribute input over both sinks, and output a
--   final result as soon as one or the other finishes.
newtype ZipSink i u m a
ZipSink :: Pipe i Void u m a -> ZipSink i u m a
[getZipSink] :: ZipSink i u m a -> Pipe i Void u m a

-- | Distribute input to both sinks, and finishes with the final result
--   once both finish.
--   
--   Forms an identity with <a>pure</a>.
zipSink :: Monad m => Pipe i Void u m (a -> b) -> Pipe i Void u m a -> Pipe i Void u m b

-- | Distribute input to both sinks, and finishes with the result of the
--   one that finishes first.
altSink :: Monad m => Pipe i Void u m a -> Pipe i Void u m a -> Pipe i Void u m a

-- | A source is essentially equivalent to <a>ListT</a> producing a
--   <a>Maybe</a> result. This converts it to the <a>ListT</a> it encodes.
--   
--   See <a>ZipSource</a> for a wrapper over <a>Pipe</a> that gives the
--   right <a>Functor</a> and <a>Alternative</a> instances.
toListT :: Applicative m => Pipe () o u m () -> ListT m (Maybe o)

-- | A source is essentially <a>ListT</a> producing a <a>Maybe</a> result.
--   This converts a <a>ListT</a> to the source it encodes.
--   
--   See <a>ZipSource</a> for a wrapper over <a>Pipe</a> that gives the
--   right <a>Functor</a> and <a>Alternative</a> instances.
fromListT :: Monad m => ListT m (Maybe o) -> Pipe i o u m ()

-- | A source is equivalent to a <a>ListT</a> producing a <a>Maybe</a>;
--   this pattern synonym lets you treat it as such. It essentialyl wraps
--   over <a>toListT</a> and <a>fromListT</a>.
pattern PipeList :: Monad m => ListT m (Maybe a) -> Pipe () a u m ()

-- | A source can be "run" by providing a continuation to handle and
--   sequence each of its outputs. Is ths inverse of <a>genSource</a>.
--   
--   This essentially turns a pipe into a church-encoded <a>ListT</a>.
withSource :: Pipe () o u m () -> (Maybe (o, m r) -> m r) -> m r

-- | Given a "generator" of <tt>o</tt> in <tt>m</tt>, return a
--   <i>source</i> that that generator encodes. Is the inverse of
--   <a>withSource</a>.
--   
--   The generator is essentially a church-encoded <a>ListT</a>.
genSource :: (forall r. (Maybe (o, m r) -> m r) -> m r) -> Pipe i o u m ()
instance GHC.Base.Functor (Data.Conduino.ZipSink i u m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Data.Conduino.ZipSink i u m)
instance GHC.Base.Monad m => GHC.Base.Alternative (Data.Conduino.ZipSink i u m)
instance Control.Monad.Trans.Class.MonadTrans (Data.Conduino.ZipSink i u)
instance GHC.Base.Functor (Data.Conduino.ZipSource m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Data.Conduino.ZipSource m)
instance GHC.Base.Monad m => GHC.Base.Alternative (Data.Conduino.ZipSource m)
instance Control.Monad.Trans.Class.MonadTrans Data.Conduino.ZipSource


-- | A basic collection of base <a>Pipe</a>s that serve as a "prelude" for
--   the package. This module is meant to be imported qualified.
--   
--   <pre>
--   import qualified Data.Conduino.Combinators as C
--   </pre>
module Data.Conduino.Combinators

-- | Repeatedly apply an "unfolding" function to a given initial state,
--   yielding the first item in the tuple as output and updating the state
--   as the second item in the tuple. Goes on forever. See
--   <a>unfoldMaybe</a> for a version that stops.
unfold :: (s -> (o, s)) -> s -> Pipe i o u m a

-- | Repeatedly apply a function to a given starting value and yield each
--   result forever.
--   
--   <pre>
--   &gt;&gt;&gt; runPipePure $ iterate succ 0
--         .| take 5
--         .| sinkList
--   </pre>
--   
--   <ul>
--   <li><i>1,2,3,4,5</i></li>
--   </ul>
--   
--   This doesn't yield the original starting value. However, you can yield
--   it iterate after:
--   
--   <pre>
--   &gt;&gt;&gt; runPipePure $ (yield 0 &gt;&gt; iterate succ 0)
--         .| take 5
--         .| sinkList
--   </pre>
--   
--   <ul>
--   <li><i>0,1,2,3,4,5</i></li>
--   </ul>
iterate :: (o -> o) -> o -> Pipe i o u m a

-- | Repeatedly yield a given item forever.
repeat :: o -> Pipe i o u m a

-- | A version of <a>unfold</a> that can terminate and end by returning
--   <a>Nothing</a>.
unfoldMaybe :: (s -> Maybe (o, s)) -> s -> Pipe i o u m ()

-- | A version of <a>unfoldMaybe</a> that can choose the "result" value by
--   passing it in as <a>Left</a>.
unfoldEither :: (s -> Either a (o, s)) -> s -> Pipe i o u m a

-- | A version of <a>iterate</a> that can choose to terminate and stop by
--   returning <a>Nothing</a>.
iterateMaybe :: (o -> Maybe o) -> o -> Pipe i o u m ()

-- | A version of <a>iterateMaybe</a> that can specify a result value by
--   providing it in the <a>Left</a>.
iterateEither :: (o -> Either a o) -> o -> Pipe i o u m a

-- | Yield every item in a foldable container.
sourceList :: Foldable t => t a -> Pipe i a u m ()

-- | Yield a given item a certain number of times.
replicate :: Int -> o -> Pipe i o u m ()

-- | Repeat a monadic action forever, yielding each output.
--   
--   Remember that each item will only be "executed" when something
--   downstream requests output.
repeatM :: Monad m => m o -> Pipe i o u m a

-- | Repeat a monadic action, yielding the item in the <a>Just</a> every
--   time. As soon as it sees <a>Nothing</a>, stop producing forever.
--   
--   Remember that each item will only be "executed" when something
--   downstream requests output.
repeatMaybeM :: Monad m => m (Maybe o) -> Pipe i o u m ()

-- | Like <a>repeatMaybeM</a>, but allow specification of a final result
--   type.
repeatEitherM :: Monad m => m (Either a o) -> Pipe i o u m a

-- | Repeat a monadic action a given number of times, yielding each result,
--   and then stop producing forever.
--   
--   Remember that each item will only be "executed" when something
--   downstream requests output.
replicateM :: Monad m => Int -> m o -> Pipe i o u m ()

-- | Source from a given I/O handle, yielding each line drawn as a string.
--   To draw raw bytes, use <a>sourceHandle</a>.
--   
--   This stop as soon as end-of-file is reached, or an empty line is seen.
sourceHandleLines :: MonadIO m => Handle -> Pipe i String u m ()

-- | Source from each line received from <a>stdin</a>. This stops as soon
--   as end-of-file is reached, or an empty line is seen.
stdinLines :: MonadIO m => Pipe i String u m ()

-- | Source from a given I/O handle, yielding bytestrings as they are
--   pulled. If you want to retrieve each line as a string, see
--   <a>sourceHandleLines</a>.
sourceHandle :: MonadIO m => Handle -> Pipe i ByteString u m ()

-- | Source from stdin, yielding bytestrings as they are drawn. If you want
--   to retrieve each line as a string, see <a>stdinLines</a>.
stdin :: MonadIO m => Pipe i ByteString u m ()

-- | Process every incoming item with a pure function, and yield its
--   output.
map :: (i -> o) -> Pipe i o u m u

-- | Map a monadic function to process every input, and yield its output.
mapM :: Monad m => (i -> m o) -> Pipe i o u m u

-- | Execute a monadic function to process every input, passing through the
--   original value back downstream.
iterM :: Monad m => (i -> m ()) -> Pipe i i u m u

-- | Like <a>foldl</a>, but yields every accumulator value downstream.
--   
--   <pre>
--   &gt;&gt;&gt; runPipePure $ sourceList [1..10]
--         .| scan (+) 0
--         .| sinkList
--   [1,3,6,10,15,21,28,36,45,55]
--   @
--   </pre>
scan :: (o -> i -> o) -> o -> Pipe i o u m u

-- | Map a pure "stateful" function over each incoming item. Give a
--   function to update the state and return an output and an initial
--   state.
mapAccum :: (i -> s -> (s, o)) -> s -> Pipe i o u m u

-- | Let a given number of items pass through the stream uninhibited, and
--   then stop producing forever.
--   
--   This is most useful if you sequence a second conduit after it.
--   
--   <pre>
--   &gt;&gt;&gt; runPipePure $ sourceList [1..8]
--         .| (do take 3 .| map (*2)         -- double the first 3 items
--                map negate                 -- negate the rest
--            )
--         .| sinkList
--   [2,4,6,-4,-5,-6,-7,-8]
--   </pre>
take :: Int -> Pipe i i u m ()

-- | Let elements pass until an element is received that does not satisfy
--   the predicate, then stop producing forever.
--   
--   Like <a>take</a>, is most useful if you sequence a second conduit
--   after it.
takeWhile :: (i -> Bool) -> Pipe i i u m ()

-- | Only allow values satisfying a predicate to pass.
filter :: (i -> Bool) -> Pipe i i u m u

-- | Map a function returning a container onto every incoming item, and
--   yield all of the outputs from that function.
concatMap :: Foldable t => (i -> t o) -> Pipe i o u m u

-- | Take an input of containers and output each of their elements
--   successively.
concat :: Foldable t => Pipe (t i) i u m u

-- | Yield consecutive pairs of values.
--   
--   <pre>
--   &gt;&gt;&gt; runPipePure $ sourceList [1..5]
--         .| pairs
--         .| sinkList
--   [(1,2),(2,3),(3,4),(4,5)]
--   </pre>
pairs :: Pipe i (i, i) u m u

-- | Yield consecutive runs of at most <tt>n</tt> of values, starting with
--   an empty sequence.
--   
--   To get only "full" sequences, pipe with <a>filter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; runPipePure $ sourceList [1..6]
--         .| consecutive 3
--         .| map toList
--         .| sinkList
--   [[],[1],[1,2],[1,2,3],[2,3,4],[3,4,5],[4,5,6]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runPipePure $ sourceList [1..6]
--         .| consecutive 3
--         .| filter ((== 3) . Seq.length)
--         .| map toList
--         .| sinkList
--   [[1,2,3],[2,3,4],[3,4,5],[4,5,6]]
--   </pre>
consecutive :: Int -> Pipe i (Seq i) u m u

-- | Ignore a certain amount of items from the input stream, and then stop
--   producing forever.
--   
--   This is most useful if you sequence a second consumer after it:
--   
--   <pre>
--   &gt;&gt;&gt; runPipePure $ sourceList [1..8]
--         .| (drop 3 &gt;&gt; 'sinkList')
--   [4,5,6,7,8]
--   </pre>
drop :: Int -> Pipe i o u m ()

-- | Ignore items from an input stream as long as they match a predicate.
--   Afterwards, stop producing forever.
--   
--   Like for <a>drop</a>, is most useful of you sequence a second consumer
--   after it.
dropWhile :: (i -> Bool) -> Pipe i o u m ()

-- | Right-fold every input into an accumulated value.
--   
--   Essentially this builds up a giant continuation that will be run all
--   at once on the final result.
foldr :: (a -> b -> b) -> b -> Pipe a o u m b

-- | Left-fold every input into an accumulated value.
--   
--   Essentially this maintains a state and modifies that state with every
--   input, using the given accumulating function.
foldl :: (b -> a -> b) -> b -> Pipe a o u m b

-- | Fold every incoming item according to a monoidal projection, and
--   return the result once finished.
--   
--   This can be used to implement many useful consumers, like ones that
--   find the sum or the maximum item:
--   
--   <pre>
--   sum :: Num i =&gt; Pipe i o u m i
--   sum = getSum <a>$</a> foldMap Sum
--   
--   maximum :: Ord i =&gt; Pipe i o u m (Maybe i)
--   maximum = fmap getMax <a>$</a> foldMap (Just . Max)
--   </pre>
foldMap :: Monoid a => (i -> a) -> Pipe i o u m a

-- | Fold every incoming item monoidally, and return the result once
--   finished.
fold :: Monoid a => Pipe a o u m a

-- | Consume an entire input stream and ignore all of its outputs.
sinkNull :: Pipe i o u m ()

-- | Sink every incoming item into a list.
--   
--   Note that this keeps the entire list in memory until it is all
--   eventually read.
sinkList :: Pipe i o u m [i]

-- | Get the last item emitted by a stream.
--   
--   To get the first item ("head"), use <a>await</a> or
--   <a>awaitSurely</a>.
last :: Pipe i o u m (Maybe i)

-- | Sink into a given I/O handle, writing each input to the handle.
sinkHandle :: MonadIO m => Handle -> Pipe ByteString o u m ()

-- | A sink into stdout.
stdout :: MonadIO m => Pipe ByteString o u m ()

-- | A sink into stderr.
stderr :: MonadIO m => Pipe ByteString o u m ()


-- | Working with underlying monad transformers and <a>Pipe</a>.
--   
--   There is no "general abstraction" for dealing with each monad
--   transformer, but we can translate the semantics that each monad
--   transformer provides into meaningful <a>Pipe</a> operations.
--   
--   For example, a <tt><a>Pipe</a> i o u (<a>State</a> s) a</tt> is a pipe
--   working over stateful effects --- it can pull information and modify
--   an underlying state to do its job. It takes in <tt>i</tt> and outputs
--   <tt>o</tt>, using an underlying state <tt>s</tt>.
--   
--   However, such a pipe is similar to <tt>s -&gt; <a>Pipe</a> i o u
--   <a>Identity</a> (a, s)</tt>. Giving some starting state, it takes in
--   <tt>i</tt> and outputs <tt>o</tt>, and when it completes, it returns
--   an <tt>a</tt> and an <tt>s</tt>, the final state after all its
--   processing is done.
--   
--   The <i>general</i> idea is that:
--   
--   <ul>
--   <li>A pipe over a monad transformer <i>shares that monadic context</i>
--   over <i>every pipe</i> in a composition.</li>
--   </ul>
--   
--   For example, if <tt>p</tt>, <tt>q</tt>, and <tt>r</tt> are all pipes
--   over <a>StateT</a>, the <tt>p .| q .| r</tt> will all share a common
--   global state.
--   
--   If <tt>p</tt>, <tt>q</tt>, and <tt>r</tt> are all pipes over
--   <a>ExceptT</a>, then <tt>p .| q .| r</tt> will all short-circult fail
--   each other: if <tt>q</tt> fails, then they all fail, etc.
--   
--   If <tt>p</tt>, <tt>q</tt>, and <tt>r</tt> are all pipes over
--   <a>WriterT</a> then <tt>p .| q .| r</tt> will all accumulate to a
--   shared global log.
--   
--   If <tt>p</tt>, <tt>q</tt>, and <tt>r</tt> are all pipes over
--   <a>ReaderT</a> then <tt>p .| q .| r</tt> will use the same identical
--   environment.
--   
--   <ul>
--   <li>Using the <tt>runX</tt> family of functions (<a>runStateP</a>,
--   <a>runExceptP</a>, etc.) lets you <i>isolate</i> out the common
--   context within a composition of pipes.</li>
--   </ul>
--   
--   For example, if <tt>p</tt> is a pipe over <a>StateT</a>, then <tt>a .|
--   <a>void</a> (<a>runStateP</a> s0 p) .| b</tt>, <tt>a</tt> and
--   <tt>b</tt> will not be able to use the state of <tt>p</tt>.
--   
--   If <tt>p</tt> is a pipe over <a>ExceptT</a>, then in <tt>a .| void
--   (<a>runExceptP</a> p) .| b</tt>, a failure in <tt>p</tt> will not
--   cause all the others to fail.
--   
--   Both of these representations have different advantages and
--   disadvantages, that are separate and unique for each individual monad
--   transformer on a case-by-case basis. This module provides functions on
--   such a case-by-case basis as you need them.
module Data.Conduino.Lift

-- | Turn a "state-modifying <a>Pipe</a>" into a <a>Pipe</a> that runs over
--   <a>StateT</a>, so you can chain it with other <a>StateT</a> pipes.
--   
--   Note that this will <i>overwrite</i> whatever state exists with the
--   <tt>s</tt> that it gets when it terminates. If any other pipe in this
--   chain modifies or uses state, all modifications will be overwritten
--   when the <tt>(a, s)</tt>-producing pipe terminates.
stateP :: Monad m => (s -> Pipe i o u m (a, s)) -> Pipe i o u (StateT s m) a

-- | Turn a <a>Pipe</a> that runs over <a>StateT</a> into a
--   "state-modifying <a>Pipe</a>", that returns the final state when it
--   terminates.
--   
--   The main usage of this is to "isolate" the state from other pipes in
--   the same chain. For example, of <tt>p</tt>, <tt>q</tt>, and <tt>r</tt>
--   are all pipes under <a>StateT</a>, then:
--   
--   <pre>
--      p
--   .| q
--   .| r
--   </pre>
--   
--   will all share underlying state, and each can modify the state that
--   they all three share. We essentially have global state.
--   
--   However, if you use <a>runStateP</a>, you can all have them use
--   different encapsulated states.
--   
--   <pre>
--      void (runStateP s0 p)
--   .| void (runStateP s1 q)
--   .| runStateP s2 r
--   </pre>
--   
--   In this case, each of those three chained pipes will use their own
--   internal states, without sharing.
--   
--   This is also useful if you want to chain a pipe over <a>StateT</a>
--   with pipes that don't use state at all: for example if <tt>a</tt> and
--   <tt>b</tt> are "non-stateful" pipes (<i>not</i> over <a>StateT</a>),
--   you can do:
--   
--   <pre>
--      a
--   .| void (runStateP s1 q)
--   .| b
--   </pre>
--   
--   And <tt>a</tt> and <tt>b</tt> will be none the wiser to the fact that
--   <tt>q</tt> uses <a>StateT</a> internally.
--   
--   Note to avoid the usage of <a>void</a>, <a>evalStateP</a> might be
--   more useful.
runStateP :: Monad m => s -> Pipe i o u (StateT s m) a -> Pipe i o u m (a, s)

-- | Takes a <a>Pipe</a> over <a>StateT</a> and "hides" the state from the
--   outside world. Give an initial state --- the pipe behaves the same
--   way, but to the external user it is abstracted away. See
--   <a>runStateP</a> for more information.
--   
--   This can be cleaner than <a>runStateP</a> because if <tt>a</tt> is
--   <tt>()</tt>, you don't have to sprinkle in <a>void</a> everywhere.
--   However, it's only really useful if you don't need to get the final
--   state upon termination.
evalStateP :: Monad m => s -> Pipe i o u (StateT s m) a -> Pipe i o u m a

-- | Like <a>runStateP</a>, but ignoring the final result. It returns the
--   final state after the pipe succesfuly terminates.
execStateP :: Monad m => s -> Pipe i o u (StateT s m) a -> Pipe i o u m s

-- | <a>stateP</a>, but for <a>Control.Monad.Trans.State.Strict</a>.
statePS :: Monad m => (s -> Pipe i o u m (a, s)) -> Pipe i o u (StateT s m) a

-- | <a>runStateP</a>, but for <a>Control.Monad.Trans.State.Strict</a>.
runStatePS :: Monad m => s -> Pipe i o u (StateT s m) a -> Pipe i o u m (a, s)

-- | <a>evalStateP</a>, but for <a>Control.Monad.Trans.State.Strict</a>.
evalStatePS :: Monad m => s -> Pipe i o u (StateT s m) a -> Pipe i o u m a

-- | <a>execStateP</a>, but for <a>Control.Monad.Trans.State.Strict</a>.
execStatePS :: Monad m => s -> Pipe i o u (StateT s m) a -> Pipe i o u m s

-- | Turn a "failable-result" <a>Pipe</a> into a pipe over <a>ExceptT</a>.
--   
--   Note that a <a>throwE</a> failure will only ever happen when the input
--   pipe "succesfully" terminates with <a>Left</a>. It would never happen
--   before the pipe terminates, since you don't get the <tt><a>Either</a>
--   e a</tt> until the pipe succesfully terminates.
exceptP :: Monad m => Pipe i o u m (Either e a) -> Pipe i o u (ExceptT e m) a

-- | Turn a <a>Pipe</a> that runs over <a>ExceptT</a> into an
--   "early-terminating <a>Pipe</a>" that "succesfully" returns <a>Left</a>
--   or <a>Right</a>.
--   
--   The main usage of this is to "isolate" the short-circuiting failure of
--   <a>ExceptT</a> to only happen within one component of a chain. For
--   example, of <tt>p</tt>, <tt>q</tt>, and <tt>r</tt> are all pipes under
--   <a>ExceptT</a>, then:
--   
--   <pre>
--      p
--   .| q
--   .| r
--   </pre>
--   
--   will short-circuit fail if <i>any</i> of <tt>p</tt>, <tt>q</tt>, or
--   <tt>r</tt> fail. We have global failure only.
--   
--   However, if you use <a>runExceptP</a>, we isolate the short-circuiting
--   failure to only a single type.
--   
--   <pre>
--      void (runExceptP p)
--   .| void (runExceptP q)
--   .| runExceptP r
--   </pre>
--   
--   In this case, if (for example) <tt>q</tt> fails, it won't cause the
--   whole thing to fail: it will just be the same as if <tt>q</tt>
--   succesfully terminates normally.
--   
--   This is also useful if you want to chain a pipe over <a>ExceptT</a>
--   with pipes that don't have <a>ExceptT</a> at all: for example if
--   <tt>a</tt> and <tt>b</tt> are "non-erroring" pipes (<i>not</i> over
--   <a>ExceptT</a>), you can do:
--   
--   <pre>
--      a
--   .| void (runExceptP q)
--   .| b
--   </pre>
--   
--   And <tt>a</tt> and <tt>b</tt> will be none the wiser to the fact that
--   <tt>q</tt> uses <a>ExceptT</a> internally.
--   
--   Note to avoid the usage of <a>void</a>, <a>runExceptP_</a> might be
--   more useful.
runExceptP :: Monad m => Pipe i o u (ExceptT e m) a -> Pipe i o u m (Either e a)

-- | A handy version of <a>runExceptP</a> that discards its output, so it
--   can be easier to chain using <a>.|</a>. It's useful if you are using
--   <a>runExceptP</a> to "isolate" failures from the rest of a chain.
runExceptP_ :: Monad m => Pipe i o u (ExceptT e m) a -> Pipe i o u m ()

-- | Turn a "parameterized <a>Pipe</a>" into a <a>Pipe</a> that runs over
--   <a>ReaderT</a>, so you can chain it with other <a>ReaderT</a> pipes.
--   
--   Essentially, instead of directly providing the <tt>r</tt> in an <tt>r
--   -&gt; <a>Pipe</a> i o u m a</tt>, the <tt>r</tt> instead comes from
--   the globally shared environment.
readerP :: Monad m => (r -> Pipe i o u m a) -> Pipe i o u (ReaderT r m) a

-- | Turn a pipe over <a>ReaderT</a> into a directly parameterized pipe.
--   Instead of getting the parameter from the globally shared
--   <a>ReaderT</a> environment, give it directly instead.
--   
--   It can be useful to "ignore" a globally shared environment and just
--   give the <tt>r</tt> directly and immediately.
runReaderP :: Monad m => r -> Pipe i o u (ReaderT r m) a -> Pipe i o u m a

-- | Turn a pipe returning an <tt>(a, w)</tt> tuple upon termination into a
--   pipe returning <tt>a</tt>, logging the <tt>w</tt> in an underlying
--   <a>WriterT</a> context.
--   
--   This can be useful for composing your pipe with other <a>WriterT</a>
--   pipes, aggregating all to a common global log.
--   
--   However, be aware that this only ever <a>tell</a>s when the pipe
--   succesfuly terminates. It doesn't do "streaming logging" -- it only
--   makes one log payload at the point of succesful termination. To do
--   streaming logging (logging things as you get them), you should
--   probably just directly use <a>WriterT</a> instead, with <a>repeatM</a>
--   or <a>iterM</a> or something similar.
writerP :: (Monad m, Monoid w) => Pipe i o u m (a, w) -> Pipe i o u (WriterT w m) a

-- | Turn a <a>Pipe</a> that runs over <a>WriterT</a> into a <a>Pipe</a>
--   that returns the final log when it terminates.
--   
--   The main usage of this is to "isolate" the log from other pipes in the
--   same chain. For example, of <tt>p</tt>, <tt>q</tt>, and <tt>r</tt> are
--   all pipes under <a>WriterT</a>, then:
--   
--   <pre>
--      p
--   .| q
--   .| r
--   </pre>
--   
--   will all share underlying log, and all logging from any of them will
--   accumulate together in an interleaved way. It is essentially a global
--   log.
--   
--   However, if you use <a>runWriterP</a>, you can all have them use
--   different encapsulated logs.
--   
--   <pre>
--      void (runWriterP p)
--   .| void (runWriterP q)
--   .| runWriterP r
--   </pre>
--   
--   In this case, each of those three chained pipes will use their own
--   internal logs, without sharing.
--   
--   This is also useful if you want to chain a pipe over <a>WriterT</a>
--   with pipes that don't use state at all: for example if <tt>a</tt> and
--   <tt>b</tt> are "non-logging" pipes (<i>not</i> over <a>WriterT</a>),
--   you can do:
--   
--   <pre>
--      a
--   .| void (runWriterP q)
--   .| b
--   </pre>
--   
--   And <tt>a</tt> and <tt>b</tt> will be none the wiser to the fact that
--   <tt>q</tt> uses <a>WriterT</a> internally.
runWriterP :: (Monad m, Monoid w) => Pipe i o u (WriterT w m) a -> Pipe i o u m (a, w)

-- | <a>runWriterP</a>, but only returning the final log after succesful
--   termination.
execWriterP :: (Monad m, Monoid w) => Pipe i o u (WriterT w m) a -> Pipe i o u m w

-- | <a>writerP</a>, but for <a>Control.Monad.Trans.Writer.Strict</a>.
writerPS :: (Monad m, Monoid w) => Pipe i o u m (a, w) -> Pipe i o u (WriterT w m) a

-- | <a>runWriterP</a>, but for <a>Control.Monad.Trans.Writer.Strict</a>.
runWriterPS :: (Monad m, Monoid w) => Pipe i o u (WriterT w m) a -> Pipe i o u m (a, w)

-- | <a>execWriterP</a>, but for <a>Control.Monad.Trans.Writer.Strict</a>.
execWriterPS :: (Monad m, Monoid w) => Pipe i o u (WriterT w m) a -> Pipe i o u m w

-- | Turn a parameterized, state-transforming, log-producing <a>Pipe</a>
--   into a <a>Pipe</a> over <a>RWST</a>, which can be useful for chaining
--   it with other <a>RWST</a> pipes.
--   
--   See <a>stateP</a> and <a>writerP</a> for more details on caveats,
--   including:
--   
--   <ul>
--   <li>Logging only happens when the <tt>(a,s,w)</tt>-returning pipe
--   terminates. There is no "streaming logging" --- the resulting
--   <tt>w</tt> is logged all at once.</li>
--   <li>When the <tt>(a,s,w)</tt>-returning pipe terminates, whatever
--   state in the <a>RWST</a> is overwritten with the <tt>s</tt> returned.
--   If other pipes in the chain modify the <tt>s</tt>, their modifications
--   will be overwritten.</li>
--   </ul>
rwsP :: (Monad m, Monoid w) => (r -> s -> Pipe i o u m (a, s, w)) -> Pipe i o u (RWST r w s m) a

-- | Turn a <a>Pipe</a> that runs over <a>RWST</a> into a state-modifying,
--   environment-using, log-accumulating <a>Pipe</a>. See <a>runStateP</a>,
--   <a>runWriterP</a>, and <a>runReaderP</a> for the uses and semantics.
runRWSP :: (Monad m, Monoid w) => r -> s -> Pipe i o u (RWST r w s m) a -> Pipe i o u m (a, s, w)

-- | <a>runRWSP</a>, but ignoring the final state.
evalRWSP :: (Monad m, Monoid w) => r -> s -> Pipe i o u (RWST r w s m) a -> Pipe i o u m (a, w)

-- | <a>runRWSP</a>, but ignoring the result value.
execRWSP :: (Monad m, Monoid w) => r -> s -> Pipe i o u (RWST r w s m) a -> Pipe i o u m (s, w)

-- | <a>rwsP</a>, but for <a>Control.Monad.Trans.RWS.Strict</a>.
rwsPS :: (Monad m, Monoid w) => (r -> s -> Pipe i o u m (a, s, w)) -> Pipe i o u (RWST r w s m) a

-- | <a>runRWSPS</a>, but for <a>Control.Monad.Trans.RWS.Strict</a>.
runRWSPS :: (Monad m, Monoid w) => r -> s -> Pipe i o u (RWST r w s m) a -> Pipe i o u m (a, s, w)

-- | <a>evalRWSPS</a>, but for <a>Control.Monad.Trans.RWS.Strict</a>.
evalRWSPS :: (Monad m, Monoid w) => r -> s -> Pipe i o u (RWST r w s m) a -> Pipe i o u m (a, w)

-- | <a>execRWSPS</a>, but for <a>Control.Monad.Trans.RWS.Strict</a>.
execRWSPS :: (Monad m, Monoid w) => r -> s -> Pipe i o u (RWST r w s m) a -> Pipe i o u m (s, w)

-- | Like <a>exceptP</a>, but for <a>CatchT</a>. See <a>exceptP</a> for
--   usage details and caveats. In general, can be useful for chaining with
--   other <a>CatchT</a> pipes.
--   
--   Note that a <a>throwM</a> failure will only ever happen when the input
--   pipe "succesfully" terminates with <a>Left</a>. It would never happen
--   before the pipe terminates, since you don't get the <tt><a>Either</a>
--   <a>SomeException</a> a</tt> until the pipe succesfully terminates.
catchP :: Monad m => Pipe i o u m (Either SomeException a) -> Pipe i o u (CatchT m) a

-- | Like <a>runExceptP</a>, but for <a>CatchT</a>. See <a>runExceptP</a>
--   for usage details. In general, can be useful for "isolating" a
--   <a>CatchT</a> pipe from the rest of its chain.
runCatchP :: Monad m => Pipe i o u (CatchT m) a -> Pipe i o u m (Either SomeException a)
