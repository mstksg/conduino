-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lightweight composable continuation-based stream processors
--   
--   Please see the README on GitHub at
--   <a>https://github.com/mstksg/conduino#readme</a>
@package conduino
@version 0.1.0.0

module Data.Conduino.Internal

-- | Similar to Conduit
--   
--   <ul>
--   <li><tt>i</tt>: Type of input stream</li>
--   <li><tt>o</tt>: Type of output stream</li>
--   <li><tt>u</tt>: Type of the <i>result</i> of the upstream pipe
--   (Outputted when upstream pipe finishes)</li>
--   <li><tt>m</tt>: Underlying monad</li>
--   <li><tt>a</tt>: Result type (Outputted when finished)</li>
--   </ul>
--   
--   Some specializations:
--   
--   <ul>
--   <li>A pipe is a <i>source</i> if <tt>i</tt> is <tt>()</tt>: it doesn't
--   need anything to go pump out items. If a pipe is source and <tt>a</tt>
--   is <a>Void</a>, it means that it will produce forever.</li>
--   <li>A pipe is a <i>sink</i> if <tt>o</tt> is <a>Void</a>: it will
--   never yield anything else downstream.</li>
--   <li>If a pipe is both a source and a sink, it is an
--   <i>effect</i>.</li>
--   <li>Normally you can ask for input upstream with <tt>await</tt>, which
--   returns <a>Nothing</a> if the pipe upstream stops producing. However,
--   if <tt>u</tt> is <a>Void</a>, it means that the pipe upstream will
--   never stop, so you can use <tt>awaitSurely</tt> to get a guaranteed
--   answer.</li>
--   </ul>
newtype Pipe i o u m a
Pipe :: FT (PipeF i o u) m a -> Pipe i o u m a
[pipeFree] :: Pipe i o u m a -> FT (PipeF i o u) m a
data PipeF i o u a
PAwaitF :: (i -> a) -> (u -> a) -> PipeF i o u a
PYieldF :: o -> a -> PipeF i o u a
awaitEither :: Pipe i o u m (Either i u)
yield :: o -> Pipe i o u m ()
instance Control.Monad.Free.Class.MonadFree (Data.Conduino.Internal.PipeF i o u) (Data.Conduino.Internal.Pipe i o u m)
instance Control.Monad.Trans.Class.MonadTrans (Data.Conduino.Internal.Pipe i o u)
instance GHC.Base.Monad (Data.Conduino.Internal.Pipe i o u m)
instance GHC.Base.Applicative (Data.Conduino.Internal.Pipe i o u m)
instance GHC.Base.Functor (Data.Conduino.Internal.Pipe i o u m)
instance GHC.Base.Functor (Data.Conduino.Internal.PipeF i o u)

module Data.Conduino

-- | Similar to Conduit
--   
--   <ul>
--   <li><tt>i</tt>: Type of input stream</li>
--   <li><tt>o</tt>: Type of output stream</li>
--   <li><tt>u</tt>: Type of the <i>result</i> of the upstream pipe
--   (Outputted when upstream pipe finishes)</li>
--   <li><tt>m</tt>: Underlying monad</li>
--   <li><tt>a</tt>: Result type (Outputted when finished)</li>
--   </ul>
--   
--   Some specializations:
--   
--   <ul>
--   <li>A pipe is a <i>source</i> if <tt>i</tt> is <tt>()</tt>: it doesn't
--   need anything to go pump out items. If a pipe is source and <tt>a</tt>
--   is <a>Void</a>, it means that it will produce forever.</li>
--   <li>A pipe is a <i>sink</i> if <tt>o</tt> is <a>Void</a>: it will
--   never yield anything else downstream.</li>
--   <li>If a pipe is both a source and a sink, it is an
--   <i>effect</i>.</li>
--   <li>Normally you can ask for input upstream with <tt>await</tt>, which
--   returns <a>Nothing</a> if the pipe upstream stops producing. However,
--   if <tt>u</tt> is <a>Void</a>, it means that the pipe upstream will
--   never stop, so you can use <tt>awaitSurely</tt> to get a guaranteed
--   answer.</li>
--   </ul>
data Pipe i o u m a
(.|) :: Monad m => Pipe a b u m v -> Pipe b c v m r -> Pipe a c u m r
infixr 2 .|
runPipe :: Monad m => Pipe () Void u m a -> m a
awaitEither :: Pipe i o u m (Either i u)
await :: Pipe i o u m (Maybe i)
awaitSurely :: Pipe i o Void m i
repeatM :: Monad m => m o -> Pipe i o u m u
unfoldP :: (b -> Maybe (a, b)) -> b -> Pipe i a u m ()
unfoldPForever :: (b -> (a, b)) -> b -> Pipe i a u m r
iterateP :: (a -> a) -> a -> Pipe i a u m r
sourceList :: Foldable t => t a -> Pipe i a u m ()
awaitForever :: (i -> Pipe i o u m a) -> Pipe i o u m u
mapP :: (a -> b) -> Pipe a b u m u
mapMP :: Monad m => (a -> m b) -> Pipe a b u m u
dropP :: Int -> Pipe i o u m ()
foldrP :: (a -> b -> b) -> b -> Pipe a Void u m b
sinkList :: Pipe i Void u m [i]
newtype ZipSink i u m a
ZipSink :: Pipe i Void u m a -> ZipSink i u m a
[getZipSink] :: ZipSink i u m a -> Pipe i Void u m a
instance GHC.Base.Functor (Data.Conduino.ZipSink i u m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Data.Conduino.ZipSink i u m)
instance GHC.Base.Monad m => GHC.Base.Alternative (Data.Conduino.ZipSink i u m)

module Lib
someFunc :: IO ()
